September 8, 2021
Wrap up the memory footprint investigation
@commit bfe923d4deb66b8c9c519a7cad41da2d963df953


Summary:
Tests run with:
	ab -k -n 50000 -c 25
	heap 6 m

	Initial State: g1
		 99 m	RSS
		107 m	total VM.native_memory (+21m over startup)
		 50 m	VM.gc
		 26 m	VM.thread
		 12 m	VM.shared
		  8 m	VM.code
		  6 m	VM.heap

	Try #1: serial
		 82 m	RSS (17 m less than G1)
		 59 m	total VM.native_memory (+21m over startup)
		  0.1 m	VM.gc
		 17 m	VM.thread
		 12 m	VM.shared
		  8 m	VM.code
		  6 m	VM.heap

	Performance Note:

	G1 in 6m heap was 10 times slower than serial, processing 1,500
	requests per second vs 13,000 with the serial garbage collector.

Notes from footprint analysis, part 1.

	1. The memory usage test I was running was bogus.
	   You can't just measure heap at server startup, you have to measures
	   after the server had done a bunch of work.

	2. The socket timeouts during load testing were due to OSX running out
	   of client ports.  The solution is to read the request before trying
	   to write a response.  The timeouts were because:

	       1. The client opens a port and connects to the server.
	       2. The server tries to write a HTTP response without
	          reading the request.  I believe this violates the
	          HTTP/1.0 specification [3], which says:

	              After receiving and interpreting a request
	              message, a server responds in the form of
	              an HTTP response message.
	      3. The server closes the connection.
	      4. The ab client sends another request.  Since the connection
	         is closed, it opens another port and connects to the
	         server.
	      5. After repeating this ~16,000 times, OSX runs out of
	         client ports.

	   Per [2],

	       The default ephemeral port range on osx is 49152-65535,
	       which is only 16,383 ports.
	       ...
	       As each port is used, it gets put into a queue where
	       it waits for the tcp "Maximum Segment Lifetime", which
	       is configured to be 15 seconds on osx.  So if you use
	       more than 16,383 ports in 15 seconds, you're effectively
	       going to get throttled by the OS on further connections.
	       Depending on which process runs out of ports first, you
	       will get connection errors from the server, or hangs
	       from ab.

	   [1] https://stackoverflow.com/questions/11980748/java-http-request-response-from-socket-server-closing-output-stream-before-clie
	   [2] https://stackoverflow.com/a/30357879/1789168
	   [3] https://datatracker.ietf.org/doc/html/rfc1945#section-6

	3. Oracle recommends the serial garbage collector for low memory apps.




Initial State:

	Summary (VM.native_memory)
        -----------------------------
          111660KB    +7148KB   Total
            6144KB          0   Java Heap
             559KB     +185KB   Class
           25661KB    +3079KB   Thread
            8797KB    +1165KB   Code
           49756KB     +131KB   GC
             187KB      +19KB   Compiler
             176KB      +11KB   Internal
              16KB       +8KB   Other
            1317KB      +77KB   Symbol
             697KB     +281KB   Native Memory
           12004KB          0   Shared
            2754KB     +276KB   Arena Chunk
                            0   Logging
                            0   Arguments
             118KB          0   Module
                            0   Safepoint
             310KB     +187KB   Synchronization
              13KB       +1KB   Metaspace
            3136KB    +1728KB   Unknown

Try #1: UseSerial

	Summary (VM.native_memory)
        -----------------------------
           60801KB   +12101KB   Total
            6144KB          0   Java Heap
             549KB     +181KB   Class
           17450KB    +1026KB   Thread
            8140KB     +509KB   Code
             124KB      +42KB   GC
             188KB      +19KB   Compiler
             162KB      +10KB   Internal
              16KB       +8KB   Other
            1377KB      +93KB   Symbol
             649KB     +237KB   Native Memory
           12004KB          0   Shared
           10882KB    +8532KB   Arena Chunk
                            0   Logging
                            0   Arguments
             118KB          0   Module
                            0   Safepoint
             271KB     +155KB   Synchronization
              22KB      +10KB   Metaspace
            2688KB    +1280KB   Unknown